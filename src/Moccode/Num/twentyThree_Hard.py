'''
题目描述
对于给定的整数 n, 如果n的k（k>=2）进制数的所有数位全为1，则称 k（k>=2）是 n 的一个好进制。
以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。
示例 1：
输入：13
输出：3
解释：13 的 3 进制是 111。
示例 2：
输入：4681
输出：8
解释：4681 的 8 进制是 11111。
示例 3：
输入：1000000000000000000
输出：999999999999999999
解释：1000000000000000000 的 999999999999999999 进制是 11。
'''
'''
https://www.acwing.com/solution/leetcode/content/6428/
这里的求s的最大值写的有误 括号里应是10^18+1
'''

def find():
    for s in range(MAX,0,-1):
        k=int(pow(n,1/(s)))    # 潜在解
        if k!=1:
            if (pow(k,s+1)-1)/(k-1) == n:
                return k
    return n-1
# 方法好像还是有点问题 可以优化 9^1 < 10 < (9^1+9^0)  就是这个1会造成问题 所以要是循环里都没有 就只能是二进制11 而k就是n-1

if __name__ == '__main__':
    import math

    n = int(input())
    MAX = int(math.log(pow(10, 18) + 1, 2) - 1)
    print(find())